<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>陀螺仪</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { background: white; padding: 20px; border-radius: 10px; text-align: center; }
        .data { margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        .value { font-weight: bold; color: #007bff; font-size: 24px; }
        .status { color: #dc3545; font-weight: bold; margin: 10px 0; }
        button { background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 16px; }
        button:disabled { background: #6c757d; }
    </style>
</head>
<body>
    <div class="container">
        <h2>陀螺仪</h2>
        <div id="status" class="status">点击启动</div>
        <button id="startBtn">启动陀螺仪</button>
        
        <div class="data">俯仰角：<span id="pitch" class="value">3600</span>°</div>
        <div class="data">横滚角：<span id="roll" class="value">3600</span>°</div>
        <div class="data">偏航角：<span id="yaw" class="value">3600</span>°</div>
    </div>

    <script>
        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        
        // 1. 累计角度（初始3600，轴完全独立）
        let pitchTotal = 3600;  // 俯仰累计值
        let rollTotal = 3600;   // 横滚累计值
        let yawTotal = 3600;    // 偏航累计值
        
        // 2. 上一次原始值（每个轴独立初始化）
        let prevBeta = null;    // 俯仰原始值缓存
        let prevGamma = null;   // 横滚原始值缓存
        let prevAlpha = null;   // 偏航原始值缓存
        
        // 3. 防抖阈值（过滤微小抖动，避免误累计）
        const SHAKE_THRESHOLD = 0.1;

        /**
         * 修正角度跳变：仅处理当前轴的差值，完全解耦
         * @param {number} current 当前原始值
         * @param {number} previous 上一次原始值
         * @param {number} maxRange 该轴原始值总范围（如beta:360, gamma:180）
         * @param {number} threshold 跳变判定阈值（如beta:180, gamma:90）
         * @returns {number} 修正后的有效差值
         */
        function calculateDelta(current, previous, maxRange, threshold) {
            // 首次无差值/差值过小（防抖），返回0
            if (previous === null || Math.abs(current - previous) < SHAKE_THRESHOLD) {
                return 0;
            }
            
            let delta = current - previous;
            // 仅当差值超过阈值时，修正跳变（核心：只处理当前轴的跳变）
            if (Math.abs(delta) > threshold) {
                delta = delta > 0 ? (delta - maxRange) : (delta + maxRange);
            }
            return delta;
        }

        function startGyro() {
            if (!window.DeviceOrientationEvent) {
                statusEl.textContent = '设备不支持';
                return;
            }
            
            statusEl.textContent = '启动中...';
            startBtn.disabled = true;
            
            // 权限请求（保留原有逻辑）
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        startSensors();
                    } else {
                        statusEl.textContent = '权限被拒绝';
                        startBtn.disabled = false;
                    }
                }).catch(() => {
                    statusEl.textContent = '权限请求失败';
                    startBtn.disabled = false;
                });
            } else {
                startSensors();
            }
        }
        
        function startSensors() {
            let hasData = false;
            
            window.addEventListener('deviceorientation', (event) => {
                // 原始值（兜底0，避免null）
                const beta = event.beta ?? 0;     // 俯仰：-180 ~ 180 → 总范围360
                const gamma = event.gamma ?? 0;   // 横滚：-90 ~ 90 → 总范围180
                const alpha = event.alpha ?? 0;   // 偏航：0 ~ 360 → 总范围360

                // 首次初始化：仅标记状态，不计算差值（避免首次赋值导致的轴干扰）
                if (!hasData) {
                    prevBeta = beta;
                    prevGamma = gamma;
                    prevAlpha = alpha;
                    hasData = true;
                    statusEl.textContent = '数据读取中';
                    return;
                }

                // ========== 俯仰轴（仅处理beta，完全独立） ==========
                const betaDelta = calculateDelta(beta, prevBeta, 360, 180);
                if (betaDelta !== 0) { // 仅当有有效差值时更新
                    pitchTotal += betaDelta;
                    prevBeta = beta; // 仅更新当前轴的缓存
                    document.getElementById('pitch').textContent = pitchTotal.toFixed(1);
                }

                // ========== 横滚轴（仅处理gamma，完全独立） ==========
                const gammaDelta = calculateDelta(gamma, prevGamma, 180, 90);
                if (gammaDelta !== 0) { // 仅当有有效差值时更新
                    rollTotal += gammaDelta;
                    prevGamma = gamma; // 仅更新当前轴的缓存
                    document.getElementById('roll').textContent = rollTotal.toFixed(1);
                }

                // ========== 偏航轴（仅处理alpha，完全独立） ==========
                const alphaDelta = calculateDelta(alpha, prevAlpha, 360, 180);
                if (alphaDelta !== 0) { // 仅当有有效差值时更新
                    yawTotal += alphaDelta;
                    prevAlpha = alpha; // 仅更新当前轴的缓存
                    document.getElementById('yaw').textContent = yawTotal.toFixed(1);
                }
            });
            
            // 启动超时重试（保留原有逻辑）
            setTimeout(() => {
                if (!hasData) {
                    statusEl.textContent = '启动失败，请重试';
                    startBtn.disabled = false;
                    startBtn.textContent = '重试';
                }
            }, 3000);
        }
        
        // 绑定启动事件（保留原有逻辑）
        startBtn.addEventListener('click', startGyro);
    </script>
</body>
</html>
