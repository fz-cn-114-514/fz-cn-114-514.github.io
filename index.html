<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>陀螺仪</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { background: white; padding: 20px; border-radius: 10px; text-align: center; }
        .data { margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        .value { font-weight: bold; color: #007bff; font-size: 24px; }
        .status { color: #dc3545; font-weight: bold; margin: 10px 0; }
        button { background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 16px; }
        button:disabled { background: #6c757d; }
    </style>
</head>
<body>
    <div class="container">
        <h2>陀螺仪</h2>
        <div id="status" class="status">点击启动</div>
        <button id="startBtn">启动陀螺仪</button>
        
        <div class="data">俯仰角：<span id="pitch" class="value">3600</span>°</div>
        <div class="data">横滚角：<span id="roll" class="value">3600</span>°</div>
        <div class="data">偏航角：<span id="yaw" class="value">3600</span>°</div>
    </div>

    <script>
        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        
        // 1. 核心状态管理（每个轴完全独立）
        const axisState = {
            pitch: {
                total: 3600,          // 累计值（初始3600）
                prev: null,           // 上一次原始值
                trend: [],            // 趋势队列（最近5帧delta方向）
                lock: false,          // 轴互斥锁
                speed: 0              // 旋转速度（用于动态阈值）
            },
            roll: {
                total: 3600,
                prev: null,
                trend: [],
                lock: false,
                speed: 0
            },
            yaw: {
                total: 3600,
                prev: null,
                trend: [],
                lock: false,
                speed: 0
            }
        };

        // 2. 动态配置（升级为5取3趋势判定，适配手机高性能）
        const DYNAMIC_CONFIG = {
            fastSpeed: 2.0,          // 快速旋转判定阈值（°/帧）
            slowThreshold: 0.3,      // 慢速旋转防抖阈值
            fastThreshold: 1.0,      // 快速旋转防抖阈值
            trendLength: 5,          // 趋势判定帧数（升级为5帧）
            trendValid: 3,           // 5取3：至少3帧同方向才判定为有效趋势
            jumpThresholds: {
                pitch: 180, maxPitch: 360,
                roll: 90, maxRoll: 180,
                yaw: 180, maxYaw: 360
            }
        };

        /**
         * 精准修正跳变并计算有效Delta（区分方向）
         * @param {string} axis 轴名称（pitch/roll/yaw）
         * @param {number} current 当前原始值
         * @param {number} prev 上一次原始值
         * @returns {number} 修正后的有效Delta
         */
        function getCorrectedDelta(axis, current, prev) {
            if (prev === null) return 0;
            const jumpCfg = DYNAMIC_CONFIG.jumpThresholds;
            
            let delta = current - prev;
            // 修正跳变（精准匹配每个轴的范围）
            if (axis === 'pitch' && Math.abs(delta) > jumpCfg.pitch) {
                delta = delta > 0 ? delta - jumpCfg.maxPitch : delta + jumpCfg.maxPitch;
            } else if (axis === 'roll' && Math.abs(delta) > jumpCfg.roll) {
                delta = delta > 0 ? delta - jumpCfg.maxRoll : delta + jumpCfg.maxRoll;
            } else if (axis === 'yaw' && Math.abs(delta) > jumpCfg.yaw) {
                delta = delta > 0 ? delta - jumpCfg.maxYaw : delta + jumpCfg.maxYaw;
            }
            return delta;
        }

        /**
         * 判定趋势是否一致（5取3：至少3帧同方向）
         * @param {array} trend 趋势队列（1=增大，-1=减小，0=无变化）
         * @returns {number} 0=无趋势，1=增大趋势，-1=减小趋势
         */
        function getConsistentTrend(trend) {
            if (trend.length < DYNAMIC_CONFIG.trendLength) return 0;
            // 统计增大/减小的帧数
            const upCount = trend.filter(t => t === 1).length;
            const downCount = trend.filter(t => t === -1).length;
            // 5取3判定：至少3帧同方向才视为有效趋势
            if (upCount >= DYNAMIC_CONFIG.trendValid) return 1;
            if (downCount >= DYNAMIC_CONFIG.trendValid) return -1;
            return 0;
        }

        /**
         * 动态调整阈值（根据旋转速度）
         * @param {number} speed 旋转速度
         * @returns {number} 适配的防抖阈值
         */
        function getDynamicThreshold(speed) {
            return speed > DYNAMIC_CONFIG.fastSpeed 
                ? DYNAMIC_CONFIG.fastThreshold 
                : DYNAMIC_CONFIG.slowThreshold;
        }

        /**
         * 处理单轴的累计逻辑（全方向精准+5取3趋势）
         * @param {string} axis 轴名称
         * @param {number} current 原始值
         */
        function processAxis(axis, current) {
            const state = axisState[axis];
            // 1. 计算修正后的Delta
            const delta = getCorrectedDelta(axis, current, state.prev);
            // 2. 计算旋转速度（绝对值）
            state.speed = Math.abs(delta);
            // 3. 获取动态阈值
            const threshold = getDynamicThreshold(state.speed);

            // 4. 过滤微小抖动
            if (Math.abs(delta) < threshold) {
                state.trend = []; // 清空趋势
                return;
            }

            // 5. 更新趋势队列（1=增大，-1=减小）
            state.trend.push(delta > 0 ? 1 : -1);
            if (state.trend.length > DYNAMIC_CONFIG.trendLength) {
                state.trend.shift(); // 保持队列长度为5
            }

            // 6. 判定趋势是否一致（5取3）
            const trend = getConsistentTrend(state.trend);
            if (trend === 0) return;

            // 7. 轴互斥：仅处理当前有趋势的轴，锁定其他轴
            Object.keys(axisState).forEach(ax => {
                axisState[ax].lock = ax !== axis;
            });

            // 8. 精准累计（方向100%匹配）
            state.total += delta;
            state.prev = current; // 仅更新当前轴的缓存
            // 9. 更新显示
            document.getElementById(axis).textContent = state.total.toFixed(1);

            // 10. 解锁其他轴（累计完成后，手机性能足够，可缩短解锁时间）
            setTimeout(() => {
                Object.keys(axisState).forEach(ax => {
                    axisState[ax].lock = false;
                });
            }, 30); // 手机端缩短至30ms，响应更快
        }

        function startGyro() {
            if (!window.DeviceOrientationEvent) {
                statusEl.textContent = '设备不支持';
                return;
            }
            
            statusEl.textContent = '启动中...';
            startBtn.disabled = true;
            
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        startSensors();
                    } else {
                        statusEl.textContent = '权限被拒绝';
                        startBtn.disabled = false;
                    }
                }).catch(() => {
                    statusEl.textContent = '权限请求失败';
                    startBtn.disabled = false;
                });
            } else {
                startSensors();
            }
        }
        
        function startSensors() {
            let hasData = false;
            
            window.addEventListener('deviceorientation', (event) => {
                // 原始值（兜底0，避免null）
                const beta = event.beta ?? 0;     // 俯仰：-180 ~ 180
                const gamma = event.gamma ?? 0;   // 横滚：-90 ~ 90
                const alpha = event.alpha ?? 0;   // 偏航：0 ~ 360

                // 首次初始化：仅缓存原始值，不计算
                if (!hasData) {
                    axisState.pitch.prev = beta;
                    axisState.roll.prev = gamma;
                    axisState.yaw.prev = alpha;
                    hasData = true;
                    statusEl.textContent = '数据读取中';
                    return;
                }

                // ========== 核心：仅处理未被锁定的轴（互斥） ==========
                if (!axisState.pitch.lock) {
                    processAxis('pitch', beta);
                }
                if (!axisState.roll.lock) {
                    processAxis('roll', gamma);
                }
                if (!axisState.yaw.lock) {
                    processAxis('yaw', alpha);
                }
            });
            
            // 启动超时重试
            setTimeout(() => {
                if (!hasData) {
                    statusEl.textContent = '启动失败，请重试';
                    startBtn.disabled = false;
                    startBtn.textContent = '重试';
                }
            }, 3000);
        }
        
        // 绑定启动事件
        startBtn.addEventListener('click', startGyro);
    </script>
</body>
</html>
