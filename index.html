<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>陀螺仪舵机控制</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            font-size: 24px;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            background: white;
            max-width: 100%;
            padding: 20px;
            border-radius: 10px;
            margin: 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h2 {
            text-align: center;
            font-size: 42px;
            margin-bottom: 35px;
            color: #007bff;
        }
        
        /* 开关样式 */
        .toggle-section {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .toggle-group {
            display: flex;
            align-items: center;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            min-width: 120px;
        }
        
        .toggle-label {
            font-weight: bold;
            font-size: 24px;
            color: #333;
        }
        
        /* 自定义开关样式 */
        .custom-toggle {
            position: relative;
            display: inline-block;
            width: 180px;
            height: 70px;
        }
        
        .custom-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .custom-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 40px;
        }
        
        .custom-slider:before {
            position: absolute;
            content: "OFF";
            display: flex;
            align-items: center;
            justify-content: center;
            height: 60px;
            width: 90px;
            left: 5px;
            bottom: 5px;
            background-color: white;
            color: #dc3545;
            font-size: 24px;
            font-weight: bold;
            transition: .4s;
            border-radius: 55px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        input:checked + .custom-slider {
            background-color: #28a745;
        }
        
        input:focus + .custom-slider {
            box-shadow: 0 0 1px #28a745;
        }
        
        input:checked + .custom-slider:before {
            transform: translateX(85px);
            content: "ON";
            color: #28a745;
        }
        
        /* 按钮样式 */
        .button-section {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            gap: 15px;
        }
        
        .control-button {
            background: #28a745; /* 默认绿色 */
            color: white;
            border: none;
            padding: 30px 45px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 28px;
            font-weight: bold;
            transition: all 0.1s;
            flex: 1;
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        
        .control-button:active {
            background: #dc3545; /* 触碰红色 */
            transform: scale(0.98);
        }
        
        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 通道配置样式 */
        .channel-section {
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
        }
        
        .channel-title {
            font-weight: bold;
            font-size: 28px;
            margin-bottom: 25px;
            color: #007bff;
            text-align: center;
        }
        
        .channel-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 15px;
        }
        
        .channel-col {
            flex: 1;
            text-align: center;
        }
        
        .value-display {
            background: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 36px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-height: 100px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .value-label {
            font-size: 24px;
            color: #6c757d;
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 25px;
            border: 2px solid #ced4da;
            border-radius: 15px;
            font-size: 28px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-height: 100px;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }
        
        /* 信息和状态区域 */
        .info-section {
            margin-bottom: 30px;
            background: #e9ecef;
            padding: 25px;
            border-radius: 10px;
        }
        
        .info-title {
            font-weight: bold;
            font-size: 32px;
            margin-bottom: 25px;
            color: #007bff;
        }
        
        .info-content {
            font-size: 24px;
            line-height: 1.8;
            color: #495057;
            margin-bottom: 25px;
        }
        
        .info-content p {
            margin-bottom: 15px;
        }
        
        .status-params {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 26px;
        }
        
        .status-label {
            font-weight: bold;
            color: #333;
        }
        
        .status-value {
            color: #007bff;
        }
        
        /* 调试信息 */
        .debug-section {
            background: #212529;
            color: #ffffff;
            padding: 25px;
            border-radius: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 18px;
            line-height: 1.8;
            display: flex;
            flex-direction: column-reverse;
        }
        
        .debug-line {
            margin-bottom: 15px;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h2 {
                font-size: 24px;
            }
            
            .toggle-section {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            
            .custom-toggle {
                width: 120px;
                height: 50px;
            }
            
            .custom-slider:before {
                height: 40px;
                width: 50px;
                font-size: 14px;
            }
            
            input:checked + .custom-slider:before {
                transform: translateX(66px);
            }
            
            .button-section {
                flex-direction: column;
                gap: 20px;
            }
            
            .channel-row {
                flex-direction: column;
                gap: 15px;
            }
            
            .channel-section {
                padding: 20px;
            }
            
            .info-section {
                padding: 20px;
            }
            
            .debug-section {
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>ESP32手机陀螺仪控制舵机by_fzcn</h2>
        
        <!-- 开关部分 -->
        <div class="toggle-section">
            <div class="toggle-group">
                <span class="toggle-label">启用控制</span>
                <label class="custom-toggle">
                    <input type="checkbox" id="controlSwitch" checked>
                    <span class="custom-slider"></span>
                </label>
            </div>
            
            <div class="toggle-group">
                <span class="toggle-label">操作解锁</span>
                <label class="custom-toggle">
                    <input type="checkbox" id="lockSwitch" checked>
                    <span class="custom-slider"></span>
                </label>
            </div>
            
            <div class="toggle-group">
                <span class="toggle-label">陀螺仪开关</span>
                <label class="custom-toggle">
                    <input type="checkbox" id="sensorSwitch">
                    <span class="custom-slider"></span>
                </label>
            </div>
        </div>
        
        <!-- 按钮部分 -->
        <div class="button-section">
            <button class="control-button" id="resetServoBtn">舵机回中</button>
            <button class="control-button" id="resetAttitudeBtn">映射归零</button>
        </div>
        
        <!-- 通道配置 - Pitch -->
        <div class="channel-section">
            <div class="channel-title">俯仰角 (Pitch)</div>
            
            <!-- 行一：原始数据、映射角度、每度脉宽 -->
            <div class="channel-row">
                <div class="channel-col">
                    <div class="value-label">传感器原始数据</div>
                    <div id="pitchRaw" class="value-display">0.0°</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">映射角度</div>
                    <div id="pitchMapped" class="value-display">0.0°</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">每度脉宽 (Rate)</div>
                    <input type="number" id="pitchRate" step="0.01" min="-50.00" max="50.00" value="5.55">
                </div>
            </div>
            
            <!-- 行二：最小脉宽、当前脉宽、最大脉宽 -->
            <div class="channel-row">
                <div class="channel-col">
                    <div class="value-label">最小脉宽</div>
                    <input type="number" id="pitchMin" step="1" min="100" max="2500" value="500">
                </div>
                
                <div class="channel-col">
                    <div class="value-label">当前脉宽</div>
                    <div id="pitchPulse" class="value-display">1500us</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">最大脉宽</div>
                    <input type="number" id="pitchMax" step="1" min="100" max="2500" value="2500">
                </div>
            </div>
        </div>
        
        <!-- 通道配置 - Roll -->
        <div class="channel-section">
            <div class="channel-title">横滚角 (Roll)</div>
            
            <!-- 行一：原始数据、映射角度、每度脉宽 -->
            <div class="channel-row">
                <div class="channel-col">
                    <div class="value-label">传感器原始数据</div>
                    <div id="rollRaw" class="value-display">0.0°</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">映射角度</div>
                    <div id="rollMapped" class="value-display">0.0°</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">每度脉宽 (Rate)</div>
                    <input type="number" id="rollRate" step="0.01" min="-50.00" max="50.00" value="5.55">
                </div>
            </div>
            
            <!-- 行二：最小脉宽、当前脉宽、最大脉宽 -->
            <div class="channel-row">
                <div class="channel-col">
                    <div class="value-label">最小脉宽</div>
                    <input type="number" id="rollMin" step="1" min="100" max="2500" value="500">
                </div>
                
                <div class="channel-col">
                    <div class="value-label">当前脉宽</div>
                    <div id="rollPulse" class="value-display">1500us</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">最大脉宽</div>
                    <input type="number" id="rollMax" step="1" min="100" max="2500" value="2500">
                </div>
            </div>
        </div>
        
        <!-- 通道配置 - Yaw -->
        <div class="channel-section">
            <div class="channel-title">偏航角 (Yaw)</div>
            
            <!-- 行一：原始数据、映射角度、每度脉宽 -->
            <div class="channel-row">
                <div class="channel-col">
                    <div class="value-label">传感器原始数据</div>
                    <div id="yawRaw" class="value-display">0.0°</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">映射角度</div>
                    <div id="yawMapped" class="value-display">0.0°</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">每度脉宽 (Rate)</div>
                    <input type="number" id="yawRate" step="0.01" min="-50.00" max="50.00" value="5.55">
                </div>
            </div>
            
            <!-- 行二：最小脉宽、当前脉宽、最大脉宽 -->
            <div class="channel-row">
                <div class="channel-col">
                    <div class="value-label">最小脉宽</div>
                    <input type="number" id="yawMin" step="1" min="100" max="2500" value="500">
                </div>
                
                <div class="channel-col">
                    <div class="value-label">当前脉宽</div>
                    <div id="yawPulse" class="value-display">1500us</div>
                </div>
                
                <div class="channel-col">
                    <div class="value-label">最大脉宽</div>
                    <input type="number" id="yawMax" step="1" min="100" max="2500" value="2500">
                </div>
            </div>
        </div>
        
        <!-- 信息和状态区域 -->
        <div class="info-section">
            <div class="info-title">网页状态参数</div>
            <div class="status-params">
                <div class="status-row">
                    <span class="status-label">WebSocket状态:</span>
                    <span id="wsStatus" class="status-value">未连接</span>
                </div>
                <div class="status-row">
                    <span class="status-label">传感器状态:</span>
                    <span id="sensorStatus" class="status-value">已关闭</span>
                </div>
                <div class="status-row">
                    <span class="status-label">控制状态:</span>
                    <span id="controlStatus" class="status-value">已启用</span>
                </div>
                <div class="status-row">
                    <span class="status-label">锁屏状态:</span>
                    <span id="lockStatus" class="status-value">已锁定</span>
                </div>
            </div>
            
            <div class="info-title">使用说明</div>
            <div class="info-content">
                <p>1. 连接ESP32_Gyroscope热点后自动进入此页面</p>
                <p>2. 点击"陀螺仪开关"开启陀螺仪数据采集</p>
                <p>3. 调整各通道的每度脉宽和脉宽范围</p>
                <p>4. 使用"启用控制"开关控制陀螺仪对舵机的影响</p>
                <p>5. 使用"锁屏开关"防止误触操作</p>
                <p>6. "舵机回中"将所有舵机设置为1500us脉宽</p>
                <p>7. "映射归零"将当前姿态设为基准0度</p>
            </div>
            
            <div class="info-title">注意事项</div>
            <div class="info-content">
                <p>1. 首次使用需要授权陀螺仪访问权限</p>
                <p>2. 操作锁定状态下无法修改配置或执行控制指令</p>
                <p>3. 舵机回中按钮仅在关闭启用控制后可用</p>
                <p>4. 请确保舵机脉宽设置在安全范围内（500-2500us）</p>
                <p>5. 每度脉宽数值范围：-50.00 至 +50.00，负值时通道反转映射</p>
            </div>
        </div>
        
        <!-- 调试信息 -->
        <div class="debug-section" id="debugSection">
            <div class="debug-line">系统初始化完成</div>
        </div>
    </div>

    <script>
        const wsStatusEl = document.getElementById('wsStatus');
        const sensorStatusEl = document.getElementById('sensorStatus');
        const controlStatusEl = document.getElementById('controlStatus');
        const unlockStatusEl = document.getElementById('lockStatus');
        const controlSwitch = document.getElementById('controlSwitch');
        const lockSwitch = document.getElementById('lockSwitch');
        const sensorSwitch = document.getElementById('sensorSwitch');
        const resetServoBtn = document.getElementById('resetServoBtn');
        const resetAttitudeBtn = document.getElementById('resetAttitudeBtn');
        const debugSection = document.getElementById('debugSection');
        
        // WebSocket连接
        let ws = null;
        let controlEnabled = true; // 默认启用
        let operationLocked = false; // 默认解锁（ON状态）
        let sensorEnabled = false; // 默认关闭
        let lockClickCount = 0;
        let lockClickTimer = null;
        let gyroStarted = false;
        
        // 通道配置
        let channelConfig = {
            pitch: {
                rate: 5.55,
                minPulse: 500,
                maxPulse: 2500,
                offset: 0  // 姿态归零偏移量
            },
            roll: {
                rate: 5.55,
                minPulse: 500,
                maxPulse: 2500,
                offset: 0
            },
            yaw: {
                rate: 5.55,
                minPulse: 500,
                maxPulse: 2500,
                offset: 0
            }
        };
        
        // 1. 核心状态管理（每个轴完全独立）
        const axisState = {
            pitch: {
                total: 3600,          // 累计值（初始3600）
                prev: null,           // 上一次原始值
                trend: [],            // 趋势队列（最近5帧delta方向）
                lock: false,          // 轴互斥锁
                speed: 0              // 旋转速度（用于动态阈值）
            },
            roll: {
                total: 3600,
                prev: null,
                trend: [],
                lock: false,
                speed: 0
            },
            yaw: {
                total: 3600,
                prev: null,
                trend: [],
                lock: false,
                speed: 0
            }
        };

        // 2. 动态配置（升级为5取3趋势判定，适配手机高性能）
        const DYNAMIC_CONFIG = {
            fastSpeed: 2.0,          // 快速旋转判定阈值（°/帧）
            slowThreshold: 0.3,      // 慢速旋转防抖阈值
            fastThreshold: 1.0,      // 快速旋转防抖阈值
            trendLength: 5,          // 趋势判定帧数（升级为5帧）
            trendValid: 3,           // 5取3：至少3帧同方向才判定为有效趋势
            jumpThresholds: {
                pitch: 180, maxPitch: 360,
                roll: 90, maxRoll: 180,
                yaw: 180, maxYaw: 360
            }
        };
        
        // 3. 数据获取标志
        let hasGyroData = false;
        
        // 添加调试信息
        function addDebugInfo(text) {
            const debugLine = document.createElement('div');
            debugLine.className = 'debug-line';
            debugLine.textContent = '[' + new Date().toLocaleTimeString() + '] ' + text;
            debugSection.insertBefore(debugLine, debugSection.firstChild);
            
            // 限制调试信息数量
            if (debugSection.children.length > 50) {
                debugSection.removeChild(debugSection.lastChild);
            }
        }
        
        // 显示警告信息
        function showWarning(text) {
            // 检查是否已有警告信息
            let warningEl = document.getElementById('rangeWarning');
            if (!warningEl) {
                // 创建警告元素
                warningEl = document.createElement('div');
                warningEl.id = 'rangeWarning';
                warningEl.style.cssText = `
                    position: fixed;
                    top: 10px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: red;
                    color: white;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-size: 24px;
                    font-weight: bold;
                    z-index: 1000;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                    animation: fadeInOut 3s ease-in-out;
                `;
                
                // 添加动画样式
                const styleEl = document.createElement('style');
                styleEl.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                        20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                        80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                        100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                    }
                `;
                document.head.appendChild(styleEl);
                
                document.body.appendChild(warningEl);
            }
            
            // 更新警告文本
            warningEl.textContent = text;
            
            // 重置动画
            warningEl.style.animation = 'none';
            setTimeout(() => {
                warningEl.style.animation = 'fadeInOut 3s ease-in-out';
            }, 10);
            
            // 3秒后移除警告
            setTimeout(() => {
                if (warningEl.parentNode) {
                    warningEl.parentNode.removeChild(warningEl);
                }
            }, 3000);
        }
        
        /**
         * 精准修正跳变并计算有效Delta（区分方向）
         * @param {string} axis 轴名称（pitch/roll/yaw）
         * @param {number} current 当前原始值
         * @param {number} prev 上一次原始值
         * @returns {number} 修正后的有效Delta
         */
        function getCorrectedDelta(axis, current, prev) {
            if (prev === null) return 0;
            const jumpCfg = DYNAMIC_CONFIG.jumpThresholds;
            
            let delta = current - prev;
            // 修正跳变（精准匹配每个轴的范围）
            if (axis === 'pitch' && Math.abs(delta) > jumpCfg.pitch) {
                delta = delta > 0 ? delta - jumpCfg.maxPitch : delta + jumpCfg.maxPitch;
            } else if (axis === 'roll' && Math.abs(delta) > jumpCfg.roll) {
                delta = delta > 0 ? delta - jumpCfg.maxRoll : delta + jumpCfg.maxRoll;
            } else if (axis === 'yaw' && Math.abs(delta) > jumpCfg.yaw) {
                delta = delta > 0 ? delta - jumpCfg.maxYaw : delta + jumpCfg.maxYaw;
            }
            return delta;
        }

        /**
         * 判定趋势是否一致（5取3：至少3帧同方向）
         * @param {array} trend 趋势队列（1=增大，-1=减小，0=无变化）
         * @returns {number} 0=无趋势，1=增大趋势，-1=减小趋势
         */
        function getConsistentTrend(trend) {
            if (trend.length < DYNAMIC_CONFIG.trendLength) return 0;
            // 统计增大/减小的帧数
            const upCount = trend.filter(t => t === 1).length;
            const downCount = trend.filter(t => t === -1).length;
            // 5取3判定：至少3帧同方向才视为有效趋势
            if (upCount >= DYNAMIC_CONFIG.trendValid) return 1;
            if (downCount >= DYNAMIC_CONFIG.trendValid) return -1;
            return 0;
        }

        /**
         * 动态调整阈值（根据旋转速度）
         * @param {number} speed 旋转速度
         * @returns {number} 适配的防抖阈值
         */
        function getDynamicThreshold(speed) {
            return speed > DYNAMIC_CONFIG.fastSpeed
                ? DYNAMIC_CONFIG.fastThreshold
                : DYNAMIC_CONFIG.slowThreshold;
        }

        /**
         * 处理单轴的累计逻辑（全方向精准+5取3趋势）
         * @param {string} axis 轴名称
         * @param {number} current 原始值
         */
        function processAxis(axis, current) {
            const state = axisState[axis];
            // 1. 计算修正后的Delta
            const delta = getCorrectedDelta(axis, current, state.prev);
            // 2. 计算旋转速度（绝对值）
            state.speed = Math.abs(delta);
            // 3. 获取动态阈值
            const threshold = getDynamicThreshold(state.speed);

            // 4. 过滤微小抖动
            if (Math.abs(delta) < threshold) {
                state.trend = []; // 清空趋势
                return 0;
            }

            // 5. 更新趋势队列（1=增大，-1=减小）
            state.trend.push(delta > 0 ? 1 : -1);
            if (state.trend.length > DYNAMIC_CONFIG.trendLength) {
                state.trend.shift(); // 保持队列长度为5
            }

            // 6. 判定趋势是否一致（5取3）
            const trend = getConsistentTrend(state.trend);
            if (trend === 0) return 0;

            // 7. 轴互斥：仅处理当前有趋势的轴，锁定其他轴
            Object.keys(axisState).forEach(ax => {
                axisState[ax].lock = ax !== axis;
            });

            // 8. 精准累计（方向100%匹配）
            state.total += delta;
            state.prev = current; // 仅更新当前轴的缓存
            
            // 9. 解锁其他轴（累计完成后，手机性能足够，可缩短解锁时间）
            setTimeout(() => {
                Object.keys(axisState).forEach(ax => {
                    axisState[ax].lock = false;
                });
            }, 30); // 手机端缩短至30ms，响应更快
            
            return delta;
        }
        
        // 连接WebSocket
        function connectWebSocket() {
            // 使用ESP32的IP地址和WebSocket端口
            const wsUrl = 'ws://192.168.4.1:81';
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    addDebugInfo('WebSocket连接已打开');
                    wsStatusEl.textContent = '已连接';
                    wsStatusEl.style.color = '#28a745';
                };
                
                ws.onmessage = function(event) {
                    const data = event.data;
                    addDebugInfo('收到消息: ' + data);
                    
                    // 处理JSON数据
                    if (data.startsWith('{')) {
                        try {
                            const jsonData = JSON.parse(data);
                            
                            // 更新映射角度
                            if (jsonData.pitch_mapped !== undefined) {
                                document.getElementById('pitchMapped').textContent = jsonData.pitch_mapped + '°';
                            }
                            if (jsonData.roll_mapped !== undefined) {
                                document.getElementById('rollMapped').textContent = jsonData.roll_mapped + '°';
                            }
                            if (jsonData.yaw_mapped !== undefined) {
                                document.getElementById('yawMapped').textContent = jsonData.yaw_mapped + '°';
                            }
                            
                            // 更新脉宽数值
                            if (jsonData.pitch_pulse !== undefined) {
                                document.getElementById('pitchPulse').textContent = jsonData.pitch_pulse + 'us';
                            }
                            if (jsonData.roll_pulse !== undefined) {
                                document.getElementById('rollPulse').textContent = jsonData.roll_pulse + 'us';
                            }
                            if (jsonData.yaw_pulse !== undefined) {
                                document.getElementById('yawPulse').textContent = jsonData.yaw_pulse + 'us';
                            }
                        } catch (e) {
                            addDebugInfo('JSON解析错误: ' + e.message);
                        }
                    }
                };
                
                ws.onerror = function(error) {
                    addDebugInfo('WebSocket错误: ' + error);
                    wsStatusEl.textContent = '连接错误';
                    wsStatusEl.style.color = '#dc3545';
                };
                
                ws.onclose = function() {
                    addDebugInfo('WebSocket连接已关闭');
                    wsStatusEl.textContent = '未连接';
                    wsStatusEl.style.color = '#dc3545';
                    // 尝试重新连接
                    setTimeout(connectWebSocket, 3000);
                };
            } catch (error) {
                addDebugInfo('WebSocket连接失败: ' + error);
                wsStatusEl.textContent = '连接失败';
                wsStatusEl.style.color = '#dc3545';
                // 尝试重新连接
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        // 发送数据到ESP32（支持简化JSON格式）
        function sendData(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            }
        }
        
        // 发送配置数据到ESP32
        function sendConfig() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const config = {
                    controlEnabled: controlEnabled ? 1 : 0,
                    operationLocked: operationLocked ? 1 : 0,
                    pitch: {
                        rate: channelConfig.pitch.rate,
                        minPulse: channelConfig.pitch.minPulse,
                        maxPulse: channelConfig.pitch.maxPulse
                    },
                    roll: {
                        rate: channelConfig.roll.rate,
                        minPulse: channelConfig.roll.minPulse,
                        maxPulse: channelConfig.roll.maxPulse
                    },
                    yaw: {
                        rate: channelConfig.yaw.rate,
                        minPulse: channelConfig.yaw.minPulse,
                        maxPulse: channelConfig.yaw.maxPulse
                    }
                };
                ws.send(JSON.stringify(config));
            }
        }
        
        // 发送控制指令
        function sendCommand(command) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(command);
            }
        }
        
        // 启动陀螺仪
        function startGyro() {
            if (!window.DeviceOrientationEvent) {
                sensorStatusEl.textContent = '设备不支持';
                sensorStatusEl.style.color = '#dc3545';
                addDebugInfo('设备不支持陀螺仪');
                gyroStarted = false;
                return;
            }
            
            sensorStatusEl.textContent = '启动中...';
            sensorStatusEl.style.color = '#ffc107';
            addDebugInfo('正在获取陀螺仪权限...');
            
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        startSensors();
                        gyroStarted = true; // 权限获取成功，设置为true
                    } else {
                        sensorStatusEl.textContent = '权限被拒绝';
                        sensorStatusEl.style.color = '#dc3545';
                        addDebugInfo('陀螺仪权限被拒绝');
                        gyroStarted = false; // 权限被拒绝，重置为false
                    }
                }).catch(() => {
                    sensorStatusEl.textContent = '权限请求失败';
                    sensorStatusEl.style.color = '#dc3545';
                    addDebugInfo('陀螺仪权限请求失败');
                    gyroStarted = false; // 权限请求失败，重置为false
                });
            } else {
                startSensors();
                gyroStarted = true; // 不需要权限，直接设置为true
            }
        }
        
        // 设备方向事件处理函数
        function handleDeviceOrientation(event) {
            if (!gyroStarted) return;
            
            // 原始值（兜底0，避免null）
            const beta = event.beta ?? 0;     // 俯仰：-180 ~ 180
            const gamma = event.gamma ?? 0;   // 横滚：-90 ~ 90
            const alpha = event.alpha ?? 0;   // 偏航：0 ~ 360

            // 首次初始化：仅缓存原始值，不计算差值
            if (!hasGyroData) {
                axisState.pitch.prev = beta;
                axisState.roll.prev = gamma;
                axisState.yaw.prev = alpha;
                hasGyroData = true;
                
                // 立即更新显示
                const pitchRaw = axisState.pitch.total.toFixed(1);
                const rollRaw = axisState.roll.total.toFixed(1);
                const yawRaw = axisState.yaw.total.toFixed(1);
                
                document.getElementById('pitchRaw').textContent = pitchRaw + '°';
                document.getElementById('rollRaw').textContent = rollRaw + '°';
                document.getElementById('yawRaw').textContent = yawRaw + '°';
                
                return;
            }

            // ========== 核心：仅处理未被锁定的轴（互斥） ==========
            if (!axisState.pitch.lock) {
                processAxis('pitch', beta);
            }
            if (!axisState.roll.lock) {
                processAxis('roll', gamma);
            }
            if (!axisState.yaw.lock) {
                processAxis('yaw', alpha);
            }

            // 计算相对角度值
            const pitchRel = axisState.pitch.total - 3600;
            const rollRel = axisState.roll.total - 3600;
            const yawRel = axisState.yaw.total - 3600;
            
            // 计算映射角度（当前相对角度 - 偏移量）
            const pitchMapped = pitchRel - channelConfig.pitch.offset;
            const rollMapped = rollRel - channelConfig.roll.offset;
            const yawMapped = yawRel - channelConfig.yaw.offset;
            
            // 限制映射角度在±180°范围内
            const pitchMappedLimited = Math.max(-180, Math.min(180, pitchMapped));
            const rollMappedLimited = Math.max(-180, Math.min(180, rollMapped));
            const yawMappedLimited = Math.max(-180, Math.min(180, yawMapped));
            
            // 计算脉宽：1500 + (映射角度 * rate)
            let pitchPulse = 1500 + (pitchMappedLimited * channelConfig.pitch.rate);
            let rollPulse = 1500 + (rollMappedLimited * channelConfig.roll.rate);
            let yawPulse = 1500 + (yawMappedLimited * channelConfig.yaw.rate);
            
            // 限制脉宽在最小和最大值之间
            pitchPulse = Math.max(channelConfig.pitch.minPulse, Math.min(channelConfig.pitch.maxPulse, pitchPulse));
            rollPulse = Math.max(channelConfig.roll.minPulse, Math.min(channelConfig.roll.maxPulse, rollPulse));
            yawPulse = Math.max(channelConfig.yaw.minPulse, Math.min(channelConfig.yaw.maxPulse, yawPulse));
            
            // 格式化显示
            const pitchRaw = axisState.pitch.total.toFixed(1);
            const rollRaw = axisState.roll.total.toFixed(1);
            const yawRaw = axisState.yaw.total.toFixed(1);
            
            // 更新显示
            document.getElementById('pitchRaw').textContent = pitchRaw + '°';
            document.getElementById('rollRaw').textContent = rollRaw + '°';
            document.getElementById('yawRaw').textContent = yawRaw + '°';
            
            // 更新映射角度显示
            document.getElementById('pitchMapped').textContent = pitchMappedLimited.toFixed(1) + '°';
            document.getElementById('rollMapped').textContent = rollMappedLimited.toFixed(1) + '°';
            document.getElementById('yawMapped').textContent = yawMappedLimited.toFixed(1) + '°';
            
            // 更新脉宽显示
            document.getElementById('pitchPulse').textContent = Math.round(pitchPulse) + 'us';
            document.getElementById('rollPulse').textContent = Math.round(rollPulse) + 'us';
            document.getElementById('yawPulse').textContent = Math.round(yawPulse) + 'us';
            
            // 检查映射角度是否超出±180°范围
            const pitchEl = document.getElementById('pitchMapped');
            const rollEl = document.getElementById('rollMapped');
            const yawEl = document.getElementById('yawMapped');
            
            // 检查映射角度是否超出±180°范围
            if (Math.abs(pitchMapped) > 180) {
                pitchEl.style.color = 'red';
                pitchEl.style.fontWeight = 'bold';
                showWarning('超出映射范围请进行姿态归零');
            } else {
                pitchEl.style.color = '#007bff';
                pitchEl.style.fontWeight = 'normal';
            }
            
            if (Math.abs(rollMapped) > 180) {
                rollEl.style.color = 'red';
                rollEl.style.fontWeight = 'bold';
                showWarning('超出映射范围请进行姿态归零');
            } else {
                rollEl.style.color = '#007bff';
                rollEl.style.fontWeight = 'normal';
            }
            
            if (Math.abs(yawMapped) > 180) {
                yawEl.style.color = 'red';
                yawEl.style.fontWeight = 'bold';
                showWarning('超出映射范围请进行姿态归零');
            } else {
                yawEl.style.color = '#007bff';
                yawEl.style.fontWeight = 'normal';
            }
            
            // 发送简化的JSON到ESP32：{s1:1500, s2:1525, s3:2525}
            if (controlEnabled) {
                const simplifiedData = {
                    s1: Math.round(pitchPulse),
                    s2: Math.round(rollPulse),
                    s3: Math.round(yawPulse)
                };
                sendData(simplifiedData);
            }
        }
        
        // 开始读取传感器数据
        function startSensors() {
            // 重置传感器状态
            hasGyroData = false;
            
            // 重置每个轴的状态
            Object.keys(axisState).forEach(axis => {
                axisState[axis].prev = null;
                axisState[axis].trend = [];
                axisState[axis].lock = false;
                axisState[axis].speed = 0;
            });
            
            // 移除旧的事件监听器，防止重复添加
            window.removeEventListener('deviceorientation', handleDeviceOrientation);
            // 添加新的事件监听器
            window.addEventListener('deviceorientation', handleDeviceOrientation);
            sensorStatusEl.textContent = '已开启';
            sensorStatusEl.style.color = '#28a745';
            addDebugInfo('陀螺仪数据读取开始');
        }
        
        // 停止读取传感器数据
        function stopSensors() {
            window.removeEventListener('deviceorientation', handleDeviceOrientation);
            sensorStatusEl.textContent = '已关闭';
            sensorStatusEl.style.color = '#dc3545';
        }
        
        // 验证RATE值，确保在±50.00范围内
        function validateRateValue(inputElement) {
            let value = parseFloat(inputElement.value);
            if (isNaN(value)) {
                value = 5.55; // 默认值
            } else if (value > 50.00) {
                value = 50.00;
            } else if (value < -50.00) {
                value = -50.00;
            }
            inputElement.value = value.toFixed(2);
            return value;
        }
        
        // 更新通道配置
        function updateChannelConfig() {
            if (operationLocked) {
                addDebugInfo('操作已锁定，无法修改配置');
                return;
            }
            
            // 获取并验证RATE值
            const pitchRate = validateRateValue(document.getElementById('pitchRate'));
            const rollRate = validateRateValue(document.getElementById('rollRate'));
            const yawRate = validateRateValue(document.getElementById('yawRate'));
            
            channelConfig.pitch.rate = pitchRate;
            channelConfig.pitch.minPulse = parseInt(document.getElementById('pitchMin').value);
            channelConfig.pitch.maxPulse = parseInt(document.getElementById('pitchMax').value);
            
            channelConfig.roll.rate = rollRate;
            channelConfig.roll.minPulse = parseInt(document.getElementById('rollMin').value);
            channelConfig.roll.maxPulse = parseInt(document.getElementById('rollMax').value);
            
            channelConfig.yaw.rate = yawRate;
            channelConfig.yaw.minPulse = parseInt(document.getElementById('yawMin').value);
            channelConfig.yaw.maxPulse = parseInt(document.getElementById('yawMax').value);
            
            sendConfig();
            addDebugInfo('通道配置已更新');
        }
        
        // 禁用或启用输入框、按钮和开关
        function updateUIState() {
            const inputs = document.querySelectorAll('input[type="number"]');
            const buttons = document.querySelectorAll('.control-button');
            const otherSwitches = document.querySelectorAll('input[type="checkbox"]:not(#lockSwitch)'); // 除了操作解锁开关外的所有开关
            
            if (operationLocked) {
                // 锁定状态，禁用所有输入、按钮和其他开关
                inputs.forEach(input => {
                    input.disabled = true;
                    input.style.opacity = '0.5';
                });
                buttons.forEach(button => {
                    button.disabled = true;
                    button.style.opacity = '0.5';
                });
                otherSwitches.forEach(switchEl => {
                    switchEl.disabled = true;
                    switchEl.parentElement.style.opacity = '0.5';
                });
            } else {
                // 解锁状态，启用所有输入、按钮和其他开关
                inputs.forEach(input => {
                    input.disabled = false;
                    input.style.opacity = '1';
                });
                // 按钮启用，除了舵机回中按钮在控制启用时禁用
                buttons.forEach(button => {
                    if (button.id === 'resetServoBtn') {
                        button.disabled = controlEnabled;
                        button.style.opacity = controlEnabled ? '0.5' : '1';
                    } else {
                        button.disabled = false;
                        button.style.opacity = '1';
                    }
                });
                otherSwitches.forEach(switchEl => {
                    switchEl.disabled = false;
                    switchEl.parentElement.style.opacity = '1';
                });
            }
        }
        
        // 事件监听器
        
        // 启用控制开关
        controlSwitch.addEventListener('change', (event) => {
            controlEnabled = event.target.checked;
            controlStatusEl.textContent = controlEnabled ? '已启用' : '已禁用';
            controlStatusEl.style.color = controlEnabled ? '#28a745' : '#dc3545';
            sendConfig();
            addDebugInfo('控制状态: ' + (controlEnabled ? '启用' : '禁用'));
            
            // 更新UI状态
            updateUIState();
        });
        
        // 操作解锁开关
        lockSwitch.addEventListener('change', (event) => {
            operationLocked = !event.target.checked; // 开关ON时解锁（未锁定），OFF时锁定
            unlockStatusEl.textContent = event.target.checked ? '已解锁' : '已锁定';
            unlockStatusEl.style.color = event.target.checked ? '#28a745' : '#dc3545';
            sendConfig();
            addDebugInfo('操作解锁状态: ' + (event.target.checked ? '解锁' : '锁定'));
            
            // 更新UI状态
            updateUIState();
        });
        
        // 陀螺仪开关
        sensorSwitch.addEventListener('change', (event) => {
            sensorEnabled = event.target.checked;
            if (sensorEnabled) {
                if (!gyroStarted) {
                    // 首次启动，需要获取权限
                    startGyro();
                    // 注意：gyroStarted会在startGyro()成功后设置为true
                } else {
                    // 已经获得权限，直接启动传感器
                    startSensors();
                }
            } else {
                stopSensors();
            }
            addDebugInfo('传感器状态: ' + (sensorEnabled ? '开启' : '关闭'));
        });
        
        // 舵机回中按钮
        resetServoBtn.addEventListener('click', () => {
            if (operationLocked) {
                addDebugInfo('操作已锁定，无法执行此操作');
                return;
            }
            if (controlEnabled) {
                addDebugInfo('启用控制时无法使用舵机回中功能');
                return;
            }
            addDebugInfo('发送舵机回中指令');
            sendCommand('reset_servo');
        });
        
        // 映射归零按钮
        resetAttitudeBtn.addEventListener('click', () => {
            if (operationLocked) {
                addDebugInfo('操作已锁定，无法执行此操作');
                return;
            }
            addDebugInfo('发送映射归零指令');
            sendCommand('reset_attitude');
        });
        
        // RATE输入框实时验证
        document.getElementById('pitchRate').addEventListener('input', function() {
            validateRateValue(this);
        });
        document.getElementById('rollRate').addEventListener('input', function() {
            validateRateValue(this);
        });
        document.getElementById('yawRate').addEventListener('input', function() {
            validateRateValue(this);
        });
        
        // 通道配置输入变化
        document.getElementById('pitchRate').addEventListener('change', updateChannelConfig);
        document.getElementById('pitchMin').addEventListener('change', updateChannelConfig);
        document.getElementById('pitchMax').addEventListener('change', updateChannelConfig);
        
        document.getElementById('rollRate').addEventListener('change', updateChannelConfig);
        document.getElementById('rollMin').addEventListener('change', updateChannelConfig);
        document.getElementById('rollMax').addEventListener('change', updateChannelConfig);
        
        document.getElementById('yawRate').addEventListener('change', updateChannelConfig);
        document.getElementById('yawMin').addEventListener('change', updateChannelConfig);
        document.getElementById('yawMax').addEventListener('change', updateChannelConfig);
        
        // 页面加载时尝试连接WebSocket
        window.addEventListener('load', connectWebSocket);
        
        // 初始化状态显示
        controlStatusEl.textContent = controlEnabled ? '已启用' : '已禁用';
        controlStatusEl.style.color = controlEnabled ? '#28a745' : '#dc3545';
        
        unlockStatusEl.textContent = !operationLocked ? '已解锁' : '已锁定';
        unlockStatusEl.style.color = !operationLocked ? '#28a745' : '#dc3545';
        
        sensorStatusEl.textContent = sensorEnabled ? '已开启' : '已关闭';
        sensorStatusEl.style.color = sensorEnabled ? '#28a745' : '#dc3545';
        
        // 初始化UI状态
        updateUIState();
        
        // 初始化调试信息
        addDebugInfo('页面加载完成');
    </script>
</body>
</html>
